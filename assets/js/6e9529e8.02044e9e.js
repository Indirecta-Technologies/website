"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6012],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),p=s(n),u=a,m=p["".concat(l,".").concat(u)]||p[u]||h[u]||i;return n?r.createElement(m,o(o({ref:t},d),{},{components:n})):r.createElement(m,o({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[p]="string"==typeof e?e:a,o[1]=c;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5646:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>s});var r=n(7462),a=(n(7294),n(3905));const i={sidebar_position:2},o="\ud83d\udcf6 NFC",c={unversionedId:"nfc",id:"nfc",title:"\ud83d\udcf6 NFC",description:"Indirecta Near Field Communication Protocol",source:"@site/docs/nfc.md",sourceDirName:".",slug:"/nfc",permalink:"/website/docs/nfc",draft:!1,editUrl:"https://www.youtube.com/watch?v=dQw4w9WgXcQ&pp=ygUXbmV2ZXIgZ29ubmEgZ2l2ZSB5b3UgdXA%3D/docs/nfc.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udd10 iSEA",permalink:"/website/docs/isea"},next:{title:"\ud83d\uded7 OpenLift",permalink:"/website/docs/openlift"}},l={},s=[{value:"Indirecta Near Field Communication Protocol",id:"indirecta-near-field-communication-protocol",level:2},{value:"Our take on NFC Functionality, in Roblox",id:"our-take-on-nfc-functionality-in-roblox",level:3},{value:"\ud83d\udd12NFC Protocol Encryption &amp; Decryption",id:"nfc-protocol-encryption--decryption",level:2},{value:"\ud83d\udcd6 _enc",id:"-_enc",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Returns",id:"returns",level:3},{value:"Example usage",id:"example-usage",level:3},{value:"\ud83d\udcd6 _dec",id:"-_dec",level:3},{value:"Parameters:",id:"parameters-1",level:3},{value:"Returns:",id:"returns-1",level:3},{value:"Example usage:",id:"example-usage-1",level:3},{value:"\ud83d\udca0 NFC Protocol Transmission &amp; Reception",id:"-nfc-protocol-transmission--reception",level:2},{value:"\ud83d\udce4 Transmission (client1 -&gt; server -&gt; client1)",id:"-transmission-client1---server---client1",level:3},{value:"\ud83d\udce5 Reception (client2 -&gt; server -&gt; client1)",id:"-reception-client2---server---client1",level:3}],d={toc:s},p="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"-nfc"},"\ud83d\udcf6 NFC"),(0,a.kt)("h2",{id:"indirecta-near-field-communication-protocol"},"Indirecta Near Field Communication Protocol"),(0,a.kt)("h3",{id:"our-take-on-nfc-functionality-in-roblox"},"Our take on NFC Functionality, in Roblox"),(0,a.kt)("p",null,"This protocol allows different FOSD devices to transmit and receive data, for example, the iComm and a door access control keypad, an rfid fob, etc."),(0,a.kt)("h2",{id:"nfc-protocol-encryption--decryption"},"\ud83d\udd12NFC Protocol Encryption & Decryption"),(0,a.kt)("h3",{id:"-_enc"},"\ud83d\udcd6 _enc"),(0,a.kt)("p",null,"Encrypts a string using a vector-based XOR encryption algorithm."),(0,a.kt)("h3",{id:"parameters"},"Parameters"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"string"),": The string to be encrypted."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Vector3"),": A Vector3 object containing encryption key values.")),(0,a.kt)("h3",{id:"returns"},"Returns"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"string"),": \ud83d\udd10 The encrypted string.")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"\u270f\ufe0f Algorithm Design"),"This function takes a string and a Vector3 object as input. It performs a character-wise XOR encryption on the string using the key values from the Vector3 object. Each character of the string is XORed with the corresponding key part, and the encrypted characters are concatenated to form the encrypted string.",(0,a.kt)("p",null,"The encryption algorithm works as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The string is iterated character by character."),(0,a.kt)("li",{parentName:"ol"},"The ASCII value of the character is obtained using string.byte."),(0,a.kt)("li",{parentName:"ol"},"The key part (X, Y, or Z) is selected based on the keyIndex, which cycles through the key values."),(0,a.kt)("li",{parentName:"ol"},"The character value is XORed with the key part value using bit32.bxor."),(0,a.kt)("li",{parentName:"ol"},"The encrypted character is converted back to a string using string.char."),(0,a.kt)("li",{parentName:"ol"},"The encrypted character is appended to the encrypted string.\t"),(0,a.kt)("li",{parentName:"ol"},"The keyIndex is incremented and wrapped around to 1 if it exceeds 3."),(0,a.kt)("li",{parentName:"ol"},"Steps 2-7 are repeated for each character in the string."),(0,a.kt)("li",{parentName:"ol"},"The final encrypted string is returned."))),(0,a.kt)("h3",{id:"example-usage"},"Example usage"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'    local str = "Hello, world!"\n    local v3 = Vector3.new(1, 2, 3)\n    local encryptedStr = NFC:_enc(str, v3)\n    print(encryptedStr)\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'NFC._enc = function(self, str: string, v3: Vector3)\n    local encrypted = ""\n    local keyIndex = 1\n    local key = {v3.X, v3.Y, v3.Z}\n\n    for i = 1, #str do\n        local char = string.byte(str, i)\n        local keyPart = key[keyIndex]\n        local encryptedChar = bit32.bxor(char, keyPart)\n        encrypted = encrypted .. string.char(encryptedChar)\n\n        keyIndex = keyIndex + 1\n        if keyIndex > 3 then\n            keyIndex = 1\n        end\n    end\n\n    return encrypted\nend\n')),(0,a.kt)("h3",{id:"-_dec"},"\ud83d\udcd6 _dec"),(0,a.kt)("p",null,"Decrypts an encrypted string using a vector-based XOR decryption algorithm."),(0,a.kt)("h3",{id:"parameters-1"},"Parameters:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"string"),": The encrypted string to be decrypted."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Vector3"),": A Vector3 object containing decryption key values.")),(0,a.kt)("h3",{id:"returns-1"},"Returns:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"string"),": \ud83d\udd13 The decrypted string.")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"\u270f\ufe0f Algorithm Design"),"This function takes an encrypted string and a Vector3 object as input. It performs a character-wise XOR decryption on the string using the key values from the Vector3 object. Each character of the encrypted string is XORed with the corresponding key part, and the decrypted characters are concatenated to form the original string.",(0,a.kt)("p",null,"The decryption algorithm works in a similar way to the encryption algorithm:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"1. The encrypted string is iterated character by character.\n2. The ASCII value of the character is obtained using string.byte.\n3. The key part (X, Y, or Z) is selected based on the keyIndex, which cycles through the key values.\n4. The character value is XORed with the key part value using bit32.bxor.\n5. The decrypted character is converted back to a string using string.char.\n6. The decrypted character is appended to the decrypted string.\n7. The keyIndex is incremented and wrapped around to 1 if it exceeds 3.\n8. Steps 2-7 are repeated for each character in the encrypted string.\n9. The final decrypted string is returned.\n"))),(0,a.kt)("h3",{id:"example-usage-1"},"Example usage:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'    local encryptedStr = "Uryyb, jbeyq!"\n    local v3 = Vector3.new(1, 2, 3)\n    local decryptedStr = NFC:_dec(encryptedStr, v3)\n    print(decryptedStr)\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'NFC._dec = function(self, str: string, v3: Vector3)\n    local decrypted = ""\n    local keyIndex = 1\n    local key = {v3.X, v3.Y, v3.Z}\n\n    for i = 1, #str do\n        local char = string.byte(str, i)\n        local keyPart = key[keyIndex]\n        local decryptedChar = bit32.bxor(char, keyPart)\n        decrypted = decrypted .. string.char(decryptedChar)\n\n        keyIndex = keyIndex + 1\n        if keyIndex > 3 then\n            keyIndex = 1\n        end\n    end\n\n    return decrypted\nend\n')),(0,a.kt)("h2",{id:"-nfc-protocol-transmission--reception"},"\ud83d\udca0 NFC Protocol Transmission & Reception"),(0,a.kt)("h3",{id:"-transmission-client1---server---client1"},"\ud83d\udce4 Transmission (client1 -> server -> client1)"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"On the client-side (client1), the NFCt function is used to transmit NFC protocol messages to the server.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},'The function searches for a child object named "__rfidtag" within the tool handle part. If the child object is not found, it raises an assertion error and suggests creating it from the server.')),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The function constructs the data to be transmitted by concatenating the provided arguments and encrypts it using the _enc function.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},'It establishes a connection to the server-side RemoteEvent associated with "__rfidtag" and sends the encrypted data and the handle part as arguments through the server\'s FireServer method.')),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},'The function waits for a response by setting up a connection to the server\'s "OnClientEvent" event associated with "__rfidtag". Once the event is fired by the server, the transmitted data is sent.')),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"After the transmission is completed, the connection is disconnected."),(0,a.kt)("p",{parentName:"li"},"It is only natural to grant NFC transmission functionality to the client, as this allows the potential for realistic Flipper Zero-like devices to exist."))),(0,a.kt)("h3",{id:"-reception-client2---server---client1"},"\ud83d\udce5 Reception (client2 -> server -> client1)"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},'The server establishes a connection to the "Touched" event of the handle part to listen for interactions with the NFC tag represented by the "__rfidtag" object.'),(0,a.kt)("li",{parentName:"ol"},'When the handle part is touched by another part in the game, the server checks if the touched part contains the "__rfidtag" object and if it is a RemoteEvent.'),(0,a.kt)("li",{parentName:"ol"},'If the conditions are met, the server establishes a connection to the server-side "OnServerEvent" of the "__rfidtag" RemoteEvent. This connection listens for incoming data from the client2 who touched the handle part.'),(0,a.kt)("li",{parentName:"ol"},"The server decrypts the received data using the _dec function."),(0,a.kt)("li",{parentName:"ol"},'The server fires the decrypted data back to the original client (client1) using a RemoteEvent associated with "__rfidtag" through the server\'s FireClient method.'),(0,a.kt)("li",{parentName:"ol"},"A delay of 3 seconds is introduced to prevent rapid repeated interactions with the NFC tag."),(0,a.kt)("li",{parentName:"ol"},"The server sets the flag variable ff back to false, allowing subsequent interactions to trigger the process again.")))}h.isMDXComponent=!0}}]);